import Math;

class PlayScene : GameSceneBase
{
	field link;
	field level;
	field renderCounter = 0;

	constructor(level) {
		this.level = level;
		TextRenderer.PurgeCache();
	}

	function GetCameraOffsetX()
	{
			camOffsetX = Math.floor(this.link.X - 128);
			if (camOffsetX < 0) return 0;

			// Is this off by 1? Go to the right edge of the map to find out.
			if (camOffsetX >= this.level.Width * 16 - 256) {
				return this.level.Width * 16 - 256;
			}
			
			return camOffsetX;
	}

	function CameraOffsetY()
	{
		camOffsetY = Math.floor(this.link.Y - 112);
		if (camOffsetY < 0) return 0;

		// Is this off by 1? Go to the bottom edge of the map to find out.
		if (camOffsetY >= this.level.Height * 16 - 224) {
			return this.level.Width * 16 - 224;
		}

		return camOffsetY;
	}

	function Initialize() {
		this.link = new Link(1288, 220, this.level, this.level.Layers[0]);
	}

	function ProcessInput(events) {
		dx = 0.0;
		dy = 0.0;

		if (InputManager.IsKeyPressed(Key.Up)) dy = -1;
		if (InputManager.IsKeyPressed(Key.Down)) dy = 1;
		if (InputManager.IsKeyPressed(Key.Right)) dx = 1;
		if (InputManager.IsKeyPressed(Key.Left)) dx = -1;

		this.link.SetWalkingDirection(dx * 1.7, dy * 1.7);

		for (e : events) {
			if (e.Type == EventType.KeyDown) {
				if (e.Key == Key.Enter) {
					inventory = new InventoryScreen(this);
					this.SwitchToScene(inventory);
				}
			}
		}
	}

	function Update(gameCounter) {
		this.link.Update();
		this.link.MoveRequest();
	}

	field underlayOffset = -224;

	function SetAsInactiveUnderlay(transitionOffset) {
		this.underlayOffset = transitionOffset;
	}

	function PublicRender(gameScreen) { this.Render(gameScreen); }

	function Render(gameScreen) {
		// TODO: render other layers
		this.RenderLayer(this.level.Layers[0], gameScreen);
		this.RenderOverlay(gameScreen);

		++this.renderCounter;
	}

	field overlayBase = new Image("Images/overlay.png");
	function RenderOverlay() {
		top = 224 + this.underlayOffset;
		overlayBase.draw(12, top);
		rupeeCount = TextRenderer.GetOverlayNumber(GameState.Instance.Rupees, 3);
		bombCount = TextRenderer.GetOverlayNumber(GameState.Instance.Bombs, 2);
		arrowCount = TextRenderer.GetOverlayNumber(GameState.Instance.Arrows, 2);
		
		rupeeCount.draw(65, 24 + top);
		bombCount.draw(97, 24 + top);
		arrowCount.draw(121, 24 + top);
	}

	field canopy = new Image(256, 224);

	function RenderLayer(layer)
	{
		this.canopy.Fill(Colors.Transparent);

		camOffsetX = this.CameraOffsetX;
		camOffsetY = this.CameraOffsetY;

		left = camOffsetX / 16;
		right = left + 17;
		top = camOffsetY / 16;
		bottom = top + 15;
		
		left--;
		right++;
		top--;
		bottom++;

		left = left < 0 ? 0 : left;
		right = right >= this.level.Width ? this.level.Width - 1 : right;
		top = top < 0 ? 0 : top;
		bottom = bottom >= this.level.Height ? this.level.Height - 1 : bottom;
		tiles = layer.Tiles;
		
		canopyUsed = false;

		for (row = top; row <= bottom; ++row)
		{
			for (col = left; col <= right; ++col)
			{
				x = col * 16 - camOffsetX;
				y = row * 16 - camOffsetY;
				tile = tiles[col][row];
				image = tile.GetImage(this.renderCounter);
				image.draw(x, y);
				image = tile.GetCanopyImage(this.renderCounter);
				if (image != null)
				{
					this.canopy.Blit(image, x, y);
					canopyUsed = true;
				}
			}
		}

		if (this.link.Layer == layer)
		{
			this.link.Render(screen, camOffsetX, camOffsetY);
		}

		if (canopyUsed)
		{
			this.canopy.draw(0, 0);
		}
	}
}
